# 학습로그

# [Java] BigDecimal - 1

## 내용

- BigDecimal에서 사칙연산은 **BigDecimal을 반환**한다. 따라서 새로 더한 값으로 덮어쓰고 싶다면 반환값을 재할당 해주어야 한다.

```java
    private BigDecimal getTotalPrize() {
        BigDecimal localPrize = BigDecimal.ZERO;

        for (Map.Entry<Rank, Integer> result : resultMap.entrySet()) {
            localPrize = localPrize.add(
                result.getKey().getPrize()
                    .multiply(BigDecimal.valueOf(result.getValue()))
            );
        }
        return localPrize;
    }
```

이 부분에서 총 합계가 계산이 잘 안되서 원인을 한참동안 찾았다ㅠㅠ

## 링크

[BigDecimal javadocs](https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html)

# [TDD] DTO, VO - 4

## 내용

- ✨가능한 모든 도메인에 속하는 코드에 대해 테스트코드를 작성하자!
- Result 클래스는 DTO라고 생각하여 테스트하지 않았는데 생각치 못한 버그가 발생함 (Result도 수익률 계산이라는 로직을 담고 있으므로 순수한 DTO 객체라고 하긴
  어려운듯 싶다.)
- DTO와 VO의 차이
    - DTO : Entity(Domain)과 View 사이의 통신하며 Presentation Logic이 있는 객체. 로직을 가지고 있지 않는 순수한 데이터 객체. 여기저기
      흩어진 값들을 모으는 역할도 하는 듯 싶다. 호출하는 메소드를 줄이기 위해 만든 객체라고도 할 수 있다.
    - VO : 값 객체. 원시값을 포장하는 객체 같은 것들을 의미함.

# [Java] Builder패턴 - 3

## 내용

- 생성자 여부만 늘어나는 것이 있다면 Builder 패턴을 사용하면 좋다.
- 꼭 필요한 값은 Builder를 만들때 초기화 해주고, 추가적인 값들은 체이닝을 통해 선택할 수 있다. 계층적으로 설계된 클래스와 함께 사용하기 좋다고 한다.
- 2개 이상의 this() 생성자 체이닝이 이루어질때, 사용하면 유용할 듯 하다.
- Builder를 사용하는데 대한 의견   
  Builder를 구현해보았으나, 선택적 매개변수를 사용할 때 의미가 있는 것 같다. 결국 Result라는 객체는 WinningNumbers와 LottoTickets가 필수적으로
  필요하기 때문에 Builder 패턴을 사용하면 오히려 필요한 정보가 누락되는 상황이 발생할 수 있다. 대신 생성자의 입력값을 더 간단하게 수정할 수 있었다.

# [Java] EnumMap -3

## 내용

- 단순히 HashMap을 EnumMap으로 바꾸는 것 이외에 아무 차이가 없어 보였기에 어떤 효과가 있을지 공부해보았다.
    ```
    1. Performance
    : performance optimization, like a quicker hash computation since all possible keys are known in advance.  
    2. Functionality
    : EnumMap is an ordered map, in that its views will iterate in enum order.
    
    출처:https://www.baeldung.com/java-enum-map
    ```
  Key 값으로 가지고 있기 위해서는 hashing 작업이 이루어지는데 EnumMap은 이미 알고있는 키이기 때문에 빠른 해싱이 가능하다고 한다. 정확한 내부구현은 어려운 듯
  싶으니 해싱이 간편해진다는 요점을 알자.    
  또다른 기능은 EnumMap은 orderedMap이다. Enum에 명시된 순서를 유지한다.

  ### 피드백
  Key가 정해져 있다라는 특징을 이용하여 장점으로 살린 자료구조로 메모리를 최소한으로 사용하고 O(1)의 속도를 보장한다 라는 것만 아시면 될 것 같습니다 :)

## 링크

[EnumMap 설명 참고한 페이지](https://www.baeldung.com/java-enum-map)

# 학습로그 2-2

# [OOP] 결합도를 낮추고 응집도를 높이자 - 4

## 내용

- Money에서는 LottoTicket을 다 알 필요는 없고 size()만 사용된다. int 값으로 전달해줘도 된다.
- 알 필요가 없는 값은 알지 않도록 하자!

- 금액에 관련된 로직은 Money에서 담당하면 Result는 좀 더 결과를 모아주는 역할만 하는 DTO가 된다.
- 돈과 관련된 정보는 Money가 책임지게 된다. 객체의 목적을 명확히 하자!

# [Java] Cache - 4

## 내용

- LottoNumber의 값은 1~45으로 한정되므로 객체를 캐싱하여 사용하면 불필요한 객체생성을 줄일 수 있다.

# 학습로그 2-3

# [Java] ArrayList - 2

## 내용

- ArrayList는 초기크기는 10이고, 추가되는 값에 따라 크기를 늘려준다. 초기화 당시 크기를 지정해주면 소소한 성능향상이 가능하다.
- addAll을 사용하면 기존 리스트 내역을 추가가능하다.

## 링크

[ArrayList javadocs](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)



